{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/3-pemeta-hubungan-obyek-bagian-1/","result":{"data":{"site":{"siteMetadata":{"title":"Fauns At A Yard","social":[{"name":"GitHub","url":"https://github.com/taufn"},{"name":"GitLab","url":"https://gitlab.com/taufn"}]}},"blogPost":{"id":"a60dc9b7-ff4b-5de1-bcb7-071c428e4eb6","excerpt":"Pemeta Hubungan Objek adalah terjemahan harfiah dari  \"Object Relational Mapper\" , alias  ORM . Artikel Wikipedia memilih istilah  Pemetaan…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"3 - Pemeta Hubungan Objek: Pendekatan Naif\",\n  \"date\": \"2020-02-24T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Pemeta Hubungan Objek adalah terjemahan harfiah dari \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\u201CObject Relational Mapper\\u201D\"), \", alias \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ORM\"), \". Artikel Wikipedia memilih istilah \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://id.wikipedia.org/wiki/Pemetaan_objek-relasional\"\n  }), \"Pemetaan Objek-Relasional\"), \" yang saya rasa tidak tepat, karena \\u201Crelasional\\u201D bukan sebuah kata dalam Bahasa Indonesia. Saya mencoba hanya menggunakan kata serapan saat tidak ada padanan Bahasa Indonesianya.\")), mdx(\"p\", null, \"Saya menantang diri untuk membuat Pemeta Hubungan Objek dari nol, alih-alih menggunakan pustaka yang sudah tersedia. Ini saya lakukan tak lain untuk mengasah sisi teknis saya. Kesemua proses ini saya coba dokumentasikan melalui kanal ini.\"), mdx(\"h2\", {\n    \"id\": \"memahami-alur-kerja-pho\"\n  }, \"Memahami Alur Kerja PHO\"), mdx(\"p\", null, \"Desain awal PHO saya sesederhana memasukkan sebuah kelas entitas ke dalam sebuah repositori. Deskripsi tentang atribut serta perilaku keduanya diinstruksikan secara harfiah dalam kode. Ini merupakan pembuktian konsep tentang alur kerja PHO. Dari sini kemudian saya mulai mengerti apa saja yang akan diperlukan PHO nantinya.\"), mdx(\"p\", null, \"Pada titik ini terlihat kelas entitas akan memiliki banyak duplikasi nilai karena pendekatan secara manual. Contohnya, nama dan petunjuk jenis data tiap kolom tabel entitas ditulis terpisah. Nama dalam sebuah himpunan teks, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array of strings\"), \"; sedangkan petunjuk jenis data dalam sebuah antarmuka, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"interface\"), \", yang juga mengulang nama setiap kolom. Akibatnya, perubahan struktur tabel mesti saya sesuaikan paling tidak di dua tempat berbeda.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// user.entity.ts\\ninterface IUserColumns {\\n  id: number\\n  email: string\\n  password: string\\n  created_at: Date\\n  updated_at: Date\\n}\\n\\nclass User {\\n  tableName = \\\"users\\\"\\n  columns = [\\\"id\\\", \\\"email\\\", \\\"password\\\", \\\"created_at\\\", \\\"updated_at\\\"]\\n}\\n\\nexport default new User()\\n\")), mdx(\"p\", null, \"Repositori saya malah seolah menjadi kelas Tuhan. Salah satu fungsinya melakukan lebih dari satu tugas. Dari mengakses basis data, mengolah data yang diterima, sampai mengubah data menjadi informasi yang nantinya dikonsumsi oleh aplikasi klien. Tentu ini buruk untuk skalabilitas basis kode.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// user.repository.ts\\nimport UserEntity from \\\"./user.entity.ts\\\"\\n\\ninterface IUserSerialized {\\n  id: number\\n  email: string\\n  created_at: string\\n  updated_at: string\\n}\\nclass UserRepository extends BaseRepository<IUserColumns, IUserSerialized> {\\n  public async createAccount(\\n    email: string,\\n    password: string\\n  ): Promise<IUserSerialized> {\\n    // fungsi ini kemudian mengeksekusi tugas-tugas berikut:\\n    // 1. pastikan email belum pernah dipakai\\n    // 2. menyembunyikan password melalui sebuah fungsi \\\"hashing\\\"\\n    // 3. menambahkan baris baru dalam basis data\\n    // 4. mengambil kembali baris yang baru dimasukkan\\n    // 5. mengubah data dari langkah 4 ke dalam format `IUserSerialized`\\n    // 6. mengembalikan informasi sesuai format\\n  }\\n}\\n\\nexport default new UserRepository(UserEntity)\\n\")), mdx(\"p\", null, \"Semestinya, fungsi dalam repositori hanya melakukan satu hal spesifik berkaitan dengan akses basis data. Misalkan, fungsi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createAccount()\"), \" harusnya hanya menambahkan baris baru dalam basis data, dan mengembalikan baris baru ini sebagai hasil fungsi. Tugas-tugas lainnya mesti dikerjakan oleh bagian lain dari aplikasi.\"), mdx(\"h2\", {\n    \"id\": \"de-duplikasi-dengan-dekorator\"\n  }, \"De-duplikasi Dengan Dekorator\"), mdx(\"p\", null, \"Masalah pertama yang saya coba selesaikan adalah persoalan duplikasi kode. Saya menggunakan dekorator untuk solusinya. Dengan dekorator, saya bisa melakukan mendefinisikan kolom tabel entitas dan jenis datanya dalam sekali jalan.\"), mdx(\"p\", null, \"Caranya, dekorator saya akan memetakan nama kolom ke sebuah objek yang merekam seluruh entitas, dan atributnya, yang ada dalam aplikasi. Peta Objek ini yang kemudian digunakan aplikasi saya untuk memahami basis data dan hubungan antar entitas didalamnya. Sedikit terbayang kan, kenapa teknik ini disebut Pemeta Hubungan Objek?\"), mdx(\"p\", null, \"Misalkan, fungsi dekorator sebagai berikut:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// mapper.ts\\nconst objectMap = {}\\n\\nexport const Column: PropertyDecorator = (target, propertyKey) => {\\n  const className = target.constructor.name\\n\\n  if (objectMap[className]) {\\n    objectMap[className].columns.push(String(propertyKey))\\n  } else {\\n    objectMap[className] = {\\n      columns: [String(propertyKey)]\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Fungsi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Column()\"), \" memetakan atribut kelas ke dalam \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"objectMap\"), \" sebagai daftar nama-nama kolom. Kelas entitas saya pun bisa disederhanakan seperti berikut:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// user.entity.ts\\nimport { Column } from \\\"./mapper.ts\\\"\\n\\nclass User {\\n  tableName = \\\"users\\\"\\n\\n  @Column\\n  id: number\\n\\n  @Column\\n  email: string\\n\\n  @Column\\n  password: string\\n\\n  @Column\\n  created_at: Date\\n\\n  @Column\\n  updated_at: Date\\n}\\n\\nexport default new User()\\n\")), mdx(\"p\", null, \"Dan peta objek akan terbarui dengan nilai-nilai berikut:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const objectMap = {\\n  User: {\\n    columns: [\\\"id\\\", \\\"email\\\", \\\"password\\\", \\\"created_at\\\", \\\"updated_at\\\"]\\n  }\\n}\\n\")), mdx(\"p\", null, \"Kita pun bisa menambahkan dekorator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Entity()\"), \" untuk menginisiasi nilai kelas entitas dalam peta objek. Semisal:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// mapper.ts\\n// ...\\nexport const Entity: ClassDecorator = target => {\\n  // hanya inisiasi jika belum dilakukan\\n  objectMap[target.name] = objectMap[target.name] || {\\n    columns: []\\n  }\\n}\\n\")), mdx(\"p\", null, \"Dan kita tambahkan ke atas definisi kelas entitas:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// user.entity.ts\\nimport { Column, Entity } from \\\"./mapper.ts\\\"\\n\\n@Entity\\nclass User {\\n  // ...\\n}\\n\\nexport default new User()\\n\")), mdx(\"p\", null, \"Keren! Sekarang saya hanya perlu mengubah bentuk kelas entitas untuk menyinkronkan perubahan tabel basis data ke peta objek saya!\"), mdx(\"p\", null, \"Omong-omong, jangan lupa tentang urutan eksekusi dekorator dalam kelas TypeScript, seperti yang saya jelaskan dalam \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/2-decorator-dalam-typescript\"\n  }), \"artikel sebelumnya\"), \".\"), mdx(\"h2\", {\n    \"id\": \"masalah-tersisa\"\n  }, \"Masalah Tersisa\"), mdx(\"p\", null, \"Satu masalah besar yang kentara adalah kelas repositori saya yang melakukan terlalu banyak tugas. Ini akan kita selesaikan dengan menggunakan arsitektur bawang, memisahkan tanggung jawab ke lapisan-lapisan berbeda.\"), mdx(\"p\", null, \"Masalah lain adalah, karena saya mengekspor \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"instance\"), \" dari kelas entitas dan bukan kelas entitas itu sendiri, saya tidak bisa langsung menggunakan nilai ekspor ini dalam petunjuk jenis kelas repositori saya tanpa bantuan \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// perhatikan penggunaan `typeof`\\nclass SomeRepository extends BaseRepository<typeof User> {}\\n\")), mdx(\"p\", null, \"Terlihat sederhana, tapi akan sangat mengganggu selama pengembangan. Kode yang ditulis terasa bertele-tele dengan banyaknya duplikasi perintah \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof\"), \". Akan amat membantu jika saya mengekspor kelas entitas itu sendiri. Namun ini bukan tanpa tantangannya yang akan saya jelaskan dalam artikel yang akan datang.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/3-pemeta-hubungan-obyek-bagian-1/","title":"3 - Pemeta Hubungan Objek: Pendekatan Naif","tags":[],"keywords":[],"date":"February 24, 2020"},"previous":{"id":"1e49843e-5f06-56b2-93ab-966c9774055f","excerpt":"Mungkin karena TypeScript adalah  superset  dari JavaScript, bahasa ini pun punya beberapa  gotchas . Satu yang saya temui adalah urutan…","slug":"/2-decorator-dalam-typescript/","title":"2 - Decorator Dalam Typescript","date":"February 11, 2020"},"next":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"a60dc9b7-ff4b-5de1-bcb7-071c428e4eb6","previousId":"1e49843e-5f06-56b2-93ab-966c9774055f"}}}