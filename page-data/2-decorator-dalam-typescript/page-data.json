{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/2-decorator-dalam-typescript/","result":{"data":{"site":{"siteMetadata":{"title":"Fauns At A Yard","social":[{"name":"GitHub","url":"https://github.com/taufn"},{"name":"GitLab","url":"https://gitlab.com/taufn"}]}},"blogPost":{"id":"1e49843e-5f06-56b2-93ab-966c9774055f","excerpt":"Mungkin karena TypeScript adalah  superset  dari JavaScript, bahasa ini pun punya beberapa  gotchas . Satu yang saya temui adalah urutan…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"2 - Decorator Dalam Typescript\",\n  \"date\": \"2020-02-11T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Mungkin karena TypeScript adalah \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"superset\"), \" dari JavaScript, bahasa ini pun punya beberapa \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"gotchas\"), \". Satu yang saya temui adalah urutan eksekusi \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"decorator\"), \" untuk sebuah kelas.\"), mdx(\"p\", null, \"Misalkan kita memiliki kode seperti berikut.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const DecorateClass: ClassDecorator = target =>\\n  console.log(\\\"Decorate class\\\", target.name)\\nconst DecorateProp: PropertyDecorator = (target, key) =>\\n  console.log(\\\"Decorate property\\\", target.constructor.name, key)\\nconst DecorateMethod: MethodDecorator = (target, key) =>\\n  console.log(\\\"Decorate method\\\", target.constructor.name, key)\\n\\n@DecorateClass\\nclass Sample {\\n  @DecorateProp\\n  num: number\\n\\n  @DecorateMethod\\n  func() {}\\n}\\n\")), mdx(\"p\", null, \"Secara intuisi, saya berpikir \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DecorateClass\"), \" akan menjadi yang pertama dieksekusi, diikuti dengan \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DecorateProp\"), \" dan \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DecorateMethod\"), \". Namun ternyata setelah saya memeriksa konsol, catatan yang muncul adalah berikut:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Decorate property Sample num\\nDecorate method Sample func\\nDecorate class Sample\\n\")), mdx(\"p\", null, \"Ternyata \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"decorator\"), \" didalam kelas dieksekusi sebelum \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"decorator\"), \" kelas itu sendiri.\"), mdx(\"h2\", {\n    \"id\": \"studi-kasus\"\n  }, \"Studi Kasus\"), mdx(\"p\", null, \"Saya memiliki sebuah kelas \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"factory\"), \". Dari kelas ini, saya memetakan beberapa properti kelas ke sebuah obyek yang bertugas untuk menyimpan data dengan bantuan \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"decorator\"), \". Namun obyek ini bisa menyimpan lebih dari satu kelas, sehingga perlu ada identitas untuk membedakan data mana milik kelas mana. Kita bisa menggunakan nama dari kelas \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"factory\"), \" sebagai solusinya.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"interface IDataObject {\\n  [K: string]: {\\n    props: string[]\\n    methods: string[]\\n  }\\n}\\nconst dataObject: IDataObject = {}\\nconst MapClass: ClassDecorator = target => {\\n  // hanya inisiasi data jika belum dilakukan\\n  dataObject[target.name] = dataObject[target.name] || {\\n    props: [],\\n    methods: []\\n  }\\n}\\nconst MapProp: PropertyDecorator = (target, key) => {\\n  const id = target.constructor.name\\n  // hanya tambahkan data jika sudah terinisiasi\\n  if (dataObject[id]) {\\n    const prop = typeof key === \\\"string\\\" ? key : String(key)\\n    dataObject[id].props.push(prop)\\n  }\\n}\\nconst MapMethod: MethodDecorator = (target, key) => {\\n  const id = target.constructor.name\\n  // hanya tambahkan data jika sudah terinisiasi\\n  if (dataObject[id]) {\\n    const method = typeof key === \\\"string\\\" ? key : String(key)\\n    dataObject[id].methods.push(method)\\n  }\\n}\\n\\n@MapClass\\nclass SomeFactory {\\n  @MapProp\\n  num: number\\n\\n  @MapMethod\\n  func() {}\\n}\\n\\nconsole.log(dataObject)\\n\")), mdx(\"p\", null, \"Kode di atas tidak akan berjalan seperti yang kita harapkan. Obyek data tidak akan merekam nilai \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \" dan \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"methods\"), \" karena data kelas \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"factory\"), \" baru diinisiasi paling akhir. Sehingga kita mendapatkan nilai \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log(dataObject)\"), \" sebagai berikut:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"{ SomeFactory: { props: [], methods: [] } }\\u2008\\n\")), mdx(\"p\", null, \"Alih-alih yang kita harapkan:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"{ SomeFactory: { props: [\\\"num\\\"], methods: [\\\"func\\\"] } }\\u2008\\n\")), mdx(\"p\", null, \"Untuk masalah ini, kita bisa membuat semua \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"decorators\"), \" menginisiasi data jika belum dilakukan saat mereka mengakses obyek data. Misalkan seperti berikut:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// kode pseudo\\nconst id = target.name || target.constructor.name\\n\\nif (!dataObject[id]) {\\n  // inisiasi nilai jika belum tersedia\\n  dataObject[id] = {\\n    // ...data dari tipe variabel ini\\n  }\\n}\\n\\n// lakukan operasi yang dibutuhkan, misalkan memetakan fungsi kelas\\ndataObject[id].methods.push(methodName)\\n\")), mdx(\"p\", null, \"Dengan cara ini, meski urutan eksekusi \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"decorator\"), \" dibolak-balik, obyek penyimpan data akan menyimpa seluruh data seperti yang kita harapkan.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/2-decorator-dalam-typescript/","title":"2 - Decorator Dalam Typescript","tags":[],"keywords":[],"date":"February 11, 2020"},"previous":{"id":"d2798b39-2266-5dcd-b0d7-efd3ee63d95a","excerpt":"Kegagalan-kegagalan terbesar yang saya buat sepanjang dekade lepas. 1. Menerima tawaran memegang jabatan manajer teknis Seorang manajer…","slug":"/1-refleksi-dekade/","title":"1 - Refleksi Dekade","date":"January 20, 2020"},"next":{"id":"a60dc9b7-ff4b-5de1-bcb7-071c428e4eb6","excerpt":"Pemeta Hubungan Objek adalah terjemahan harfiah dari  \"Object Relational Mapper\" , alias  ORM . Artikel Wikipedia memilih istilah  Pemetaan…","slug":"/3-pemeta-hubungan-obyek-bagian-1/","title":"3 - Pemeta Hubungan Objek: Pendekatan Naif","date":"February 24, 2020"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"1e49843e-5f06-56b2-93ab-966c9774055f","previousId":"d2798b39-2266-5dcd-b0d7-efd3ee63d95a","nextId":"a60dc9b7-ff4b-5de1-bcb7-071c428e4eb6"}}}